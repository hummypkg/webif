
if {![exists -proc class]} { package require oo }
if {![exists -proc sqlite3.open]} { package require sqlite3 }
if {![exists -proc binary]} { package require binary }

class system {}

proc {system model} {} {
	if {[catch {set fp [open /etc/model r]}]} {
		set model {HD[R]}
	} else {
		set model [string trim [read $fp]]
		close $fp
	}
	return $model
}

proc {system hostname} {} {
	if {[catch {set hostname [string trim [exec hostname]]}]} {
		set hostname "humax"
	}
	return $hostname
}

proc {system ip} {} {
	if {[catch {set fp [open /etc/hosts r]}]} {
		set ip "127.0.0.1"
	} else {
		set ipl [lindex [split [$fp read] "\n"] 1]
		regsub -- {[[:space:]].*} $ipl "" ip
	}
	return $ip
}

proc {system modversion} {{short 0}} {
	if {[catch {set fp [open /etc/modversion r]}]} {
		set modver "102"
	} else {
		set modver [string trim [read $fp]]
		close $fp
	}
	if {$short} { return $modver }
	lassign [split $modver ""] a b c
	return [format "%d.%d%d" $a $b $c]
}

proc {system modbuild} {} {
	if {[catch {set fp [open /etc/modbuild r]}]} {
		return 0
	} else {
		set modbuild [string trim [read $fp]]
		close $fp
	}
	return $modbuild
}

proc {system fhtcpversion} {} {
	set file "/etc/fhtcpversion"
	if {![file exists $file]} { set file "/root/fhtcpversion" }
	if {[catch {set fp [open $file r]}]} {
		set ver "?.??.??"
	} else {
		set ver [string trim [read $fp]]
		close $fp
	}
	return $ver
}

# 822272+6 - MAC address
# 833536 - Serial number
proc {system serialno} {} {
	set fd [open /dev/mtd3 r]
	
	$fd seek 833536
	set bytes [$fd read 14]
	$fd close
	return "[string range $bytes 0 1] [string range $bytes 2 8] [
	    string range $bytes 9 end]"
}

proc {system kernelver} {} {
	#1 SMP Sun Mar 25 18:30:38 KST 2012
	set ver [string range [exec uname -v] 11 end]
	return [switch $ver {
		# HDR
		"Sep 16 20:17:56 KST 2010" { format "HDR_1.01.05" }
		"Oct 11 21:11:05 KST 2010" { format "HDR_1.01.09" }
		"Jan 21 15:44:39 KST 2011" { format "HDR_1.02.07" }
		"Jun 11 00:54:19 KST 2011" { format "HDR_1.02.20" }
		"Mar 25 18:30:38 KST 2012" { format "HDR_1.02.27" }
		"May 27 00:19:34 KST 2012" { format "HDR_1.02.28" }
		"Jul 5 11:11:28 KST 2012"  { format "HDR_1.02.29" }
		"Jan 12 16:49:05 KST 2013" { format "HDR_1.02.32" }
		"Mar 6 07:27:02 KST 2013"  { format "HDR_1.03.06(a)" }
		"May 8 14:32:30 KST 2013"  { format "HDR_1.03.06(b)" }
		"Dec 10 14:36:54 KST 2013" { format "HDR_1.03.11" }
		"Feb 7 14:15:02 KST 2014"  { format "HDR_1.03.12" }
		"May 19 22:39:27 BST 2014" { format "HDR_CFW_3.00" }

		# HD
		"Oct 11 21:14:31 KST 2010" { format "HD_1.01.12" }
		"May 17 14:16:20 KST 2011" { format "HD_1.02.18" }
		"Jun 11 00:54:19 KST 2011" { format "HD_1.02.20" }
		"Mar 25 07:09:19 KST 2012" { format "HD_1.02.27" }
		"May 27 00:19:40 KST 2012" { format "HD_1.02.28" }
		"Jul 5 19:41:17 KST 2012"  { format "HD_1.02.29" }
		"Oct 13 12:48:09 KST 2012" { format "HD_1.02.31" }

		default { format "Unknown - $ver" }
	}]
}

proc {system pkgver} {{pkg webif}} {
	return [lrange [split [exec opkg list-installed $pkg] " "] 2 end]
}

proc {system pkginst} {pkg} {
	return [file exists "/mod/var/opkg/info/$pkg.control"]
}

#proc {system pkginst} {pkg} {{cache {}} {ncache {}}} {
#	if {$pkg in $cache} { return 1 }
#	if {$pkg in $ncache} { return 0 }
#
#	# It may not be possible to get an opkg lock immediately so
#	# try several times and throw an error if not.
#	set status unknown
#	loop i 0 5 {
#		if {[catch {set status [exec opkg list-installed $pkg]}]} {
#			sleep 1
#		} else break
#	}
#	if {$status eq "unknown"} {
#		error "Could not get opkg lock after 5 seconds."
#	}
#
#	if {$status ne ""} {
#		lappend cache $pkg
#		return 1
#	}
#	lappend ncache $pkg
#	return 0
#}

proc {system mediaroot} {} {
	switch [system model] {
		HDR { return "/media/My Video" }
		HD { return "/media/drive1/Video" }
	}
	return ""
}

proc {system dustbin} {{short 0}} {
	set dustbin "\[Deleted Items\]"
	if {![catch {set fd [open "/mod/boot/dustbin.name" r]}]} {
		set dustbin [lindex [split [read $fd] "\n"] 0]
		$fd close
	}
	if {$short} { return $dustbin }
	return "[system mediaroot]/$dustbin"
}

proc {system diskpart} {} {
	switch [system model] {
		HDR { return "/mnt/hd2" }
		HD { return "/media/drive1" }
	}
}

proc {system diskdev} {} {
	set part [system diskpart]
	foreach line [split [\
	    exec /mod/bin/busybox/df $part 2>>/dev/null] "\n\r"] {
		if {[string match "/*" $line]} {
			lassign [split $line] dev
			break
		}
	}
	return $dev
}

proc {system disk} {} {
	return [string range [system diskdev] 0 end-1]
}

require pretty_size

proc {system diskspace} {{raw 0}} {
	set part [system diskpart]

	lassign [exec /mod/bin/busybox/stat -f -c {%S %b %f} $part] \
	    bsize blocks fblocks

	set size $($bsize * $blocks)
	set free $($bsize * $fblocks)
	set used $($size - $free)
	set perc $($used * 100 / $size)
	set fperc $(100 - $perc)

	switch [system model] {
		HDR { set tsrdir "/mnt/hd2/Tsr" }
		HD { set tsrdir "/media/drive1/.tsr" }
	}

	if {[file isdirectory $tsrdir]} {
		set tsrbuf 21474836480
		lassign [exec du -ks $tsrdir] tsrused
		set tsrused $($tsrused * 1024)
	} else {
		set tsrbuf 0
		set tsrused 0
	}

	if {!$raw} {
		set size [pretty_size $size]
		set free [pretty_size $free]
		set used [pretty_size $used]
		set tsrbuf [pretty_size $tsrbuf]
		set tsrused [pretty_size $tsrused]
	}

	return [list $size $used $perc $free $fperc $tsrbuf $tsrused]
}

proc {system diskfree} {} {
	lassign [exec /mod/bin/busybox/stat -f -c {%S %f} [system diskpart]] \
	    bsize fblocks
	return $($bsize * $fblocks)
}

proc {system busy} {} {
	# Is humaxtv doing anything important?
	if {[catch {set pid [exec /mod/bin/busybox/pgrep -n humaxtv]}]} {
		return 0
	}
	set c 0
	foreach line [split [\
	    exec /mod/webif/lib/bin/lsof -X -Fn -p $pid] "\n"] {
		if {[string match {*Video*.ts} $line]} { incr c }
	}
	if {$c > 0} { return 1 }
	return 0
}

proc {system inuse} {file} {
	set op [exec /mod/webif/lib/bin/lsof -X -Fn $file]
	if {$op eq ""} {
		return 0
	} else {
		return 1
	}
}

proc {system dirinuse} {dir} {
	set files {}
	foreach line [split [\
	    exec /mod/webif/lib/bin/lsof -X -Fn +d $dir] "\n"] {
		if {[string index $line 0] ne "n"} continue
		lappend files [file tail $line]
	}
	return $files
}

proc {system reboot} {} {
	exec /etc/init.d/S90settop shut
	exec /sbin/reboot
}

proc {system restartpending} {{mode 1}} {
	if {$mode} {
		close [open /tmp/.restartpending w]
	} else {
		file delete /tmp/.restartpending
	}
}

proc {system param} {param {type Value} {tbl MENUCONFIG}} {
	if {[catch {set db [sqlite3.open /var/lib/humaxtv/setup.db]} msg]} {
		return 0
	}
	set val 0
	set ret [$db query "
		select item$type
		from TBL_$tbl
		where itemName = '$param'
	"]
	if {[llength $ret] == 1} {
		lassign [lindex $ret 0] x val
	}
	$db close
	return $val
}

proc {system padding} {} {
	return [list \
		[system param START_PADDING_TIME] \
		[system param STOP_PADDING_TIME] \
	]
}

proc {system instandby} {} {
	return [system param LAST_STANDBY Value USERCONFIG]
}

proc {system mkdir_p} {dir} {
	exec /mod/bin/busybox/mkdir -p $dir
}

proc {system rmdir_if_empty} {dir {why 0}} {
	set fl {}
	foreach e [readdir -nocomplain $dir] {
		if {$e eq "." || $e eq ".."} continue
		if {[file isdirectory "$dir/$e"]} {
			if {!$why} { return 0 }
			lappend fl $e
		} elseif {[string index $e 0] ne "."} {
			if {!$why} { return 0 }
			lappend fl $e
		}
	}
	if {!$why} {
		file delete -force $dir
		return 1
	}
	return $fl
}

proc {system listening} {{mport 0}} {
	set ret {}
	foreach line [split [exec /mod/bin/busybox/netstat -lntpw] "\n"] {
		# Remove repeated spaces
		regsub -all -- {[[:space:]]+} $line " " line
# tcp 0 0 0.0.0.0:9955 0.0.0.0:* LISTEN 169/humaxtv
		lassign [split $line " "] x x x port x type app
		if {$type ne "LISTEN"} { continue }
		lassign [split $port ":"] x port

		if {$mport && $mport != $port} { continue }
		lappend ret [list $port [split $app "/"]]
	}
	return $ret
}

proc {system is_listening} {mport} {
	return [llength [system listening $mport]]
}

proc {system notify} {msg} {
	set logfd [open "/mod/tmp/notify.log" "a+"]
	puts $logfd "[\
	    clock format [clock seconds] -format "%d/%m/%Y %H:%M"\
	    ] - $msg"
	$logfd close
}

proc {system display} {hdr hd} {
	if {[system model] eq "HDR"} {
		exec /sbin/display $hdr
	} else {
		exec /sbin/display "\$$hd"
	}
}

proc {system uptime} {} {
	set fd [open /proc/uptime r]
	set uptime [lindex [split [read $fd]] 0]
	$fd close
	return $uptime
}

proc {system filename} {str {extra ""}} {
	# Humax TV replaces these characters.
	# "%*./:<>?\|
	set chars "\"%*\./:<>?\\\\|$extra"
	return [regsub -all "\[$chars]" $str "_"]
}

proc {system connectivity} {{site "hpkg.tv"}} {
	if {[catch {exec /bin/ping -4 -c 2 -W 3 -w 3 -q $site >/dev/null}]} {
		return 0
	}
	return 1
}

