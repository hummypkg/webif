
if {![exists -proc class]} { package require oo }

class pkg {
	name		""
	latest		""
	descr		""
	changes		""
	url		""
	installed	""
	raw		{}
}

set ::pkgmeta {}
set ::diagmeta {}

pkg method _load {nm} {
	set name $nm
	foreach line [split [exec /bin/opkg list $nm] "\n"] {
		# betaftpd - 0.0.8pre17-1 - Description...
		if {[string match { *} $line]} {
			append descr $line
		} else {
			regexp {^[^ ]+ - ([^ ]+) - (.*)$} $line x latest descr
		}
	}
	regexp {(.*) \[(.*)\]} $descr x descr changes
	set info [exec /bin/opkg list-installed $nm]
	regexp {^([^ ]+) - ([^ ]+)$} $info x x installed

	return $self
}

pkg method loadraw {} {
	set tag ""
	set txt ""
	set raw {}
	
	foreach line [split [exec /bin/opkg info $name] "\n"] {
		if {$tag ne "" && [string match { *} $line]} {
			append raw($tag) $line
			continue
		}
		regexp {^([^:]+): (.*)$} $line x tag txt
		if {![dict exists $raw $tag]} {
			set tag [string tolower $tag]
			set raw($tag) $txt
		} else {
			set tag ""
		}
	}

	if {[dict exists $raw tags]} { set url $raw(tags) }
}

proc {pkg load} {nm} {
	return [[pkg] _load $nm]
}

pkg method is {what} {
	switch $what {
		installed {
			if {$installed eq ""} { return 0 }
			return 1
		}
		upgradable {
			if {$installed eq $latest} { return 0 }
			return 1
		}
	}
	return 0
}

proc {pkg avail} {} {
	set inst_pkgs [pkg inst]
	set avail_pkgs {}
	foreach pkg [split [exec /bin/opkg list] "\n"] {
		if {[regexp {^ } $pkg]} { continue }
		if {[regexp {^([^ ]+)} $pkg name] == 0} { continue }
		if {$name ni $inst_pkgs && $name ni $avail_pkgs} {
			lappend avail_pkgs $name
		}
		#puts "New: $name<br>"
	}
	return $avail_pkgs
}

proc {pkg inst} {} {
	# Build a list of installed packages - just the names
	set inst_pkgs {}
	foreach pkg [split [exec /bin/opkg list-installed] "\n"] {
		if {[regexp {^([^ ]+)} $pkg name] == 0} { continue }
		if {$name ni $inst_pkgs} {
			lappend inst_pkgs $name
		}
		#puts "Inst: $name<br>"
	}
	return $inst_pkgs
}

proc {pkg upgr} {} {
	#webif - 0.5.3 - 0.5.7
	set upgr_pkgs {}
	foreach pkg [split [exec /bin/opkg list-upgradable] "\n"] {
		if {[regexp {^([^ ]+)} $pkg name] == 0} { continue }
		lappend upgr_pkgs $name
		#puts "Upgr: $name<br>"
	}
	return $upgr_pkgs
}

proc {pkg loadmeta} {} {
	if {[llength $::pkgmeta]} { return }
	if {![file exists "/mod/var/pkg.meta"]} {
		catch {pkg fetchmeta}
	} else {
		set meta [open "/mod/var/pkg.meta" r]
		set ::pkgmeta [read $meta]
		$meta close
	}
}

proc {pkg loaddiagmeta} {} {
	if {[llength $::diagmeta]} { return }
	if {![file exists "/mod/var/diag.meta"]} {
		catch {pkg fetchdiagmeta}
	} else {
		set meta [open "/mod/var/diag.meta" r]
		set ::diagmeta [read $meta]
		$meta close
	}
}

proc {pkg fetchfile} {url} {
	set f [socket stream hpkg.tv:80]
	$f puts -nonewline "GET /hdrfoxt2/$url HTTP/1.1\r\n"
	$f puts -nonewline "Host: hpkg.tv\r\n"
	$f puts -nonewline "Connection: close\r\n"
	$f puts -nonewline "\r\n"

	# Skip headers in the response.
	set line [string trim [$f gets]]
	while {[string length $line]} {
		#puts "Web Header: $line"
		set line [string trim [$f gets]]
	}
	
	# Save the body
	set ret [$f read]
	$f close
	return $ret
}

proc {pkg fetchmeta} {} {
	set ::pkgmeta [pkg fetchfile pkg.meta]

	set ff [open "/mod/var/pkg.meta" w]
	puts $ff $::pkgmeta
	$ff close
}

proc {pkg fetchdiagmeta} {} {
	set ::diagmeta [pkg fetchfile diag.meta]

	set ff [open "/mod/var/diag.meta" w]
	puts $ff $::diagmeta
	$ff close
}

proc {pkg update} {} {
	exec /bin/opkg update
}

proc {pkg upgrade} {nm} {
	exec /bin/opkg upgrade $nm
}

