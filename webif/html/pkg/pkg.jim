#!/mod/bin/jimsh

package require cgi
source /mod/webif/lib/setup
require settings.class pkg.class altrow

if {[[settings] pkgdev]} { set filter 0 } else { set filter 1 }

httpheader

proc pkgrow {name pkg} {
	altrow "pkg=\"$name\""
	puts "<td nowrap>$name"
	if {$::type eq "inst"} {
		puts "<br><a href=# class=depends>&nbsp;&nbsp;
		    <img class=va border=0
		    src=/images/421_1_00_CH_Title_2R_Arrow.png height=14>
		    <span class=\"va footnote\">Info</span></a>"
	}
	puts "</td>"

	if {$::type eq "avail"} {
		puts "<td nowrap>$pkg(version)</td>"
	} else {
		puts "<td nowrap>$pkg(installed)</td>"
	}

	if {$::type eq "upgr"} {
		puts "<td nowrap>$pkg(version)</td>"
	}

	puts "<td>"
	set descr $pkg(description)
	set changes ""
	regexp {(.*) \[(.*)\]} $descr x descr changes
	if {[dict exists $::pkgmeta $name]} {
		puts $::pkgmeta($name)
	} else {
		puts $descr
	}
	if {$::type eq "upgr"} {
		if {$changes ne ""} {
			puts "<br>&nbsp;&nbsp;-&nbsp;<i>$changes</i>"
		}
		if {[dict exists $pkg tags]} {
			set url $pkg(tags)
			puts "
	<br>
	<a class=va href=\"$url\" target=_blank style=\"color: darkblue\">
		<img class=va height=18 width=18 src=/img/info.png> $url
	</a>"
		}
	}
	puts "</td>"

	if {$pkg(installed) eq "0"} {
		set type Install
	} elseif {$::type eq "upgr" && $pkg(installed) ne $pkg(version)} {
		if {[pkg vercompare $pkg(version) $pkg(installed)] == 1} {
			set type Upgrade
		} else {
			set type ""
		}
	} else {
		set type Remove
	}

	puts "<td align=center>"
	if {$type ne ""} {
		puts "<small><button id=\"$name\"
		    action=[string tolower $type]
		    class=\"va [string tolower $type]\">$type</button></small>"
	} else {
		puts "<i>Newer</i>"
	}
	puts "</td>"

	puts "</tr>"
}

set pkgdata [pkg getall]
if {[file exists /mod/var/opkg/beta]} {
	set pkgdata [dict merge $pkgdata [pkg getall beta]]
}
pkg loadmeta
set type [cgi_get type "avail"]

set pkgs {}
foreach {pkg data} $pkgdata {
	switch $type {
		avail {
			if {$data(installed) eq "0"} {
				lappend pkgs $pkg
			}
		}
		inst {
			if {$data(installed) ne "0"} {
				lappend pkgs $pkg
			}
		}
		upgr {
			if {$data(installed) ne "0" && \
			    $data(installed) ne $data(version)} {
				lappend pkgs $pkg
			}
		    }
	}
}

if {[llength $pkgs] > 0} {
	puts "<table><tr><th>Package</th>"

	if {$type eq "avail"} {
		puts "<th>Available</th>"
	} else {
		puts "<th>Installed</th>"
	}

	if {$type eq "upgr"} {
		puts "<th>Avail</th>"
	}

	puts "
		<th>Description</th>
		<th>&nbsp;&nbsp;Action&nbsp;&nbsp;</th>
		</tr>
	"

	foreach pkg [lsort $pkgs] {
		if {$type ne "upgr" && $filter && \
		    ![dict exists $::pkgmeta $pkg]} continue
		if {![dict exists $pkgdata $pkg]} continue
		pkgrow $pkg $pkgdata($pkg)
	}
	puts "</table>"
	if {$type ne "upgr" && $filter} {
		puts "<font class=footnote>This is a filtered package list. To show all packages, enable the <i>Show development and advanced packages</i> in the settings screen.</font>"
	}
} else {
	puts "<i>No packages "
	switch $type {
		inst { puts "are installed." }
		upgr { puts "are available for upgrade; try updating the package list from the Internet using the button above." }
		avail { puts "are available for installation." }
	}
	puts "</i>"
}

